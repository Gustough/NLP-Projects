# Copyright (c) 2025 Rhodri Meredith & Gustav Engelmann
# Licensed under the MIT License. See LICENSE file for details.

import numpy as np
import csv
import scipy.stats 
import os

floor_taking_thresh = 2000 # milliseconds of speech used to define taking the floor i.e. not backchanneling
backchannel_length = 2000 # milliseconds of speech, shorter than which will qualify as backchanneling
backchannel_seperation = 5000 # milliseconds of speech where individual backchannels will be considered as one

class get_IM():
    """Class that takes the csv file of subjective interaction models generated by create_sim_script.py, and
        a number corresponding to the participant in the meeting: 0 for A, 1 for B, 2 for C.

        Attributes:
         - sim: numpy.ndarry of the subjective interaction model for that participant
         - oim: the corresponding objective interaction model

        Methods:
         - find_turn_durations: Returns the total amount of time a participant 
         was speaking as a fraction of the total time.

         - find_overlap: Returns the fraction of time the speaker speaks 
         simultaneously with another speaker.

         - find_skew_score: Returns a measure of temporal distribution of the turns
         of the speaker during the meeting.

         - find_backchannels: The number of times the speaker back-channels others
         during the meeting. Or if backchannel_by_speaker is False, returns the number
         of times others back-channel the speaker.
    
    """
    def __init__(self, data, speaker):
        self.sim = np.array(data[speaker], dtype=float) # Subjective interaction model

        OIM = np.zeros_like(self.sim)
        for i, val in enumerate(self.sim):
            if float(val) > 1:
                OIM[i] = 1
        self.oim = OIM # Objective interaction model
    
    def find_turn_duration(self):
        return round((np.sum(self.sim == 2) +  np.sum(self.sim == 3)) / len(self.sim), 3)
    
    def find_overlap(self):
        return round((np.sum((self.sim == 3) & ((np.roll(self.sim, 1) == 2) | (np.roll(self.sim, -1) == 2)))) / len(self.sim), 5)
    
    def find_skew_score(self):
        """ Calculates the skewness of speaker's speech patterns. Positive value means they spoke more
        at the start of the conversation, negative value means they spoke more at the end. A value
        very close to zero means they spoke roughly the same amount throughout. Fisher-Pearson 
        coefficient used as skewness score.
        """
        anchored_array = np.append(np.append([1], self.oim), [1])
        array = [i for i, val in enumerate(anchored_array) if val == 1]
        return scipy.stats.skew(array)
        
    def find_backchannels(self, backchannel_by_speaker=True):
        other_speaker_code = 2 - int(backchannel_by_speaker) # Value in SIM either side of backchannel

        counter = 0
        backchannels = [] # Instances of backchanneling in SIM
        condition1 = False # Speaker has spoken long enough to take the floor
        condition2 = False # Potential backchannel is correct length
        for i, val in enumerate(self.sim):
            if val == other_speaker_code:
                if condition2:
                    backchannels.append(i)
                    counter = 1
                else:
                    if counter > floor_taking_thresh/50:
                        condition1 = True
                        counter = 0
                    else:
                        counter += 1
                condition2 = False
            elif val == 3: # Both are speaking i.e. potentially a backchannel
                if condition1:
                    counter += 1
                    if counter < backchannel_length/50:
                        condition2 = True
                    else:
                        condition2 = False
                        condition1 = False
                else:
                    counter = 0
                    condition2 = False
            else: # Speakers turn ends
                counter = 0
                condition1 = False
                condition2 = False

        # Determine number of backchannel clusters
        backchannel_count = 0
        cut_off = 0
        for item in backchannels:
            if item > cut_off:
                backchannel_count += 1
                cut_off = item + backchannel_seperation/50
        
        return backchannels, backchannel_count


def main():
    project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    
    meeting_types = ["physical"]
    speakers = ["A", "B", "C"]
    results = {}
    for code in range(10):
        for meeting_type in meeting_types:
            output_file_path = os.path.join(project_root, "output", "SIM_files", f"ss{code}_physical.csv")
            with open(output_file_path, "r", encoding="utf-8") as f:
                data = list(csv.reader(f))
                speaker_dict = {"A": (), "B": (), "C": ()}
                for i, speaker in enumerate(speakers):
                    SIM = get_IM(data, i)
                    # Order: (turn duration, overlap, backchannels by speaker, backchannels to speaker, skewness)
                    turn_dur = SIM.find_turn_duration()
                    overlap = SIM.find_overlap()
                    backch_by = SIM.find_backchannels()[1]
                    backch_to = SIM.find_backchannels(backchannel_by_speaker=False)[1]
                    skew_score = round(float(SIM.find_skew_score()), 4)
                    speaker_dict[speaker] = (float(turn_dur), float(overlap), backch_by, backch_to, skew_score)
                
                results[(f"SESS-0{code+1:02}", meeting_type.capitalize())] = speaker_dict

    return results

if __name__ =="__main__":
    print(main())
